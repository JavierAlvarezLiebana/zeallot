% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unpack.R
\name{unpack}
\alias{unpack}
\alias{unpack.Date}
\alias{unpack.NULL}
\alias{unpack.character}
\alias{unpack.complex}
\alias{unpack.data.frame}
\alias{unpack.default}
\alias{unpack.logical}
\alias{unpack.numeric}
\alias{unpack.raw}
\alias{unpack.summary.lm}
\title{Unpack an Object}
\usage{
unpack(x)

\method{unpack}{character}(x)

\method{unpack}{numeric}(x)

\method{unpack}{logical}(x)

\method{unpack}{complex}(x)

\method{unpack}{raw}(x)

\method{unpack}{NULL}(x)

\method{unpack}{Date}(x)

\method{unpack}{data.frame}(x)

\method{unpack}{summary.lm}(x)

\method{unpack}{default}(x)
}
\arguments{
\item{x}{An \R object.}
}
\description{
\code{unpack} is used during parallel assignment to de-structure an object
and assign individual elements of a value to multiple names.
}
\details{
New implementations of \code{unpack} can be very simple. If an object does
not have elements to de-structure then simply return the object. Be sure
to return an object of length 1 or a list object so \code{\%<-\%} can handle
the returned value(s).

The default implementation of \code{unpack} raises an informative error.
}
\examples{
# data frames become a list of columns
unpack(head(iris))

# strings become a list of individual
# characters
unpack('abcdef')

# creating a new unpack implementation
shape <- function(sides = 4, color = 'red') {
  structure(
    list(sides = sides, color = color),
    class = 'shape'
  )
}

\dontrun{
{sides: color} \%<-\% shape()
}

unpack.shape <- function(x) {
  list(x$sides, x$color)
}

{sides: color} \%<-\% unpack(shape())
{sides: color} \%<-\% unpack(shape(3, 'green'))

}
\seealso{
\code{\link{\%<-\%}}
}
\keyword{internal}

