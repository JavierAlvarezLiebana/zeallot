% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unpack.R
\name{unpack}
\alias{unpack}
\alias{unpack.Date}
\alias{unpack.NULL}
\alias{unpack.character}
\alias{unpack.complex}
\alias{unpack.data.frame}
\alias{unpack.default}
\alias{unpack.logical}
\alias{unpack.numeric}
\alias{unpack.raw}
\alias{unpack.summary.lm}
\title{Unpack an Object}
\usage{
unpack(x)

\method{unpack}{character}(x)

\method{unpack}{numeric}(x)

\method{unpack}{logical}(x)

\method{unpack}{complex}(x)

\method{unpack}{raw}(x)

\method{unpack}{NULL}(x)

\method{unpack}{Date}(x)

\method{unpack}{data.frame}(x)

\method{unpack}{summary.lm}(x)

\method{unpack}{default}(x)
}
\arguments{
\item{x}{An \R object.}
}
\description{
\code{unpack} is used during parallel assignment to de-structure an object
into a list. Individual elements of this list are then assigned to names on
the left-hand side of an expression.
}
\details{
When unpacking an atomic vector, \code{unpack} expects \code{x} is a length 1
vector. If an atomic vector of length greater than 1 is passed to
\code{unpack} an error is raised.

New implementations of \code{unpack} can be very simple. A new \code{unpack}
function might simply strip away the class of a custom object and return the
underlying list structure. Alternatively, an object might unpack into a
nested set of values and may require a more complicated implementation. In
either case, new implementations must return an object of length 1 or a list
object so \code{\%<-\%} can handle the returned value(s).

The default implementation of \code{unpack} raises an informative error.
}
\examples{
# data frames become a list of columns
unpack(head(iris))

# strings are split into a list of
# individual characters
unpack('abcdef')

# dates are unpacked into a list of year,
# month, and day
unpack(Sys.Date())

# create a new unpack implementation
shape <- function(sides = 4, color = 'red') {
  structure(
    list(sides = sides, color = color),
    class = 'shape'
  )
}

\dontrun{
# cannot unpack the shape object yet
{sides: color} \%<-\% shape()
}

# implement a new unpack function
unpack.shape <- function(x) {
  list(x$sides, x$color)
}

# now we can unpack shape objects
{sides: color} \%<-\% unpack(shape())
sides  # 4
color  # 'red'

{sides: color} \%<-\% unpack(shape(3, 'green'))
sides  # 3
color  # 'green'

}
\seealso{
\code{\link{\%<-\%}}
}

