---
title: "Parallel, Multiple, and Unpacking Assignment"
author: "Nathan Teetor"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Parallel, Multiple, and Unpacking Assignment}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{R, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = '#>')

library(allotalot)
```

## Parallel Assignment
The *allotalot* package defines an operator for *parallel assignment*,
sometimes called *unpacking assignment* or *destructuring assignment*
in other programming languages.
The operator is written as `%<-%` and used like this.

```{r}
{ lat : lng } %<-% list(38.061944, -122.643889)
```

The result is that the list is unpacked into its elements,
and the elements are assigned to `lat` and `lng`.

```{r}
lat
lng
```

You can also unpack the elements of a vector.
Omit the braces ({}) in that case.

```{r}
lat : lng %<-% c(38.061944, -122.643889)
lat
lng
```

You can unpack much longer structures, too, of course,
such as the 6-part summary of a vector.

```{r}
min_wt : q1_wt : med_wt : mean_wt : q3_wt : max_wt %<-% summary(mtcars$wt)
min_wt
q1_wt
med_wt
mean_wt
q3_wt
max_wt
```

If the left-hand side and right-hand sides don't match,
an error is raised.
This guards against missing or unexpected values.

```{r, error=TRUE}
{ stg1 : stg2 : stg3 } %<-% list("Moe", "Donald")
```

```{r, error=TRUE}
{ stg1 : stg2 : stg3 } %<-% list("Moe", "Larry", "Curley", "Donald")
```

### Unpacking a returned value
A common use-case is when a function returns a list of values
and you want to extract the individual values.
In this example, the list of values returned by `coords_list()` is unpacked
into the variables `lat` and `lng`.

```{r}
#
# A function which returns a list of 2 numeric values.
# 
coords_list <- function() {
  list(38.061944, -122.643889)
}

{ lat : lng } %<-% coords_list()
lat
lng
```

As in the earlier example,
colon and braces on the left-hand side of the assignment
tell the assignment operator to expect a list.

In this example, we call a function that returns a vector.
Now we omit the braces.

```{r}
#
# Convert cartesian coordinates to polar
#
to_polar = function(x, y) {
  c(sqrt(x^2 + y^2), atan(y/x))
}

radius : angle %<-% to_polar(12, 5)
radius
angle
```

### Example: Intercept and slope of regression
We can directly unpack the coefficients of a simple linear regression
into the intercept and slope.

```{r}
inter : slope %<-% coef(lm(mpg ~ cyl, data = mtcars))
inter
slope
```

### Example: Unpacking the result of `safely`
The *purrr* package includes the `safely` function.
It wraps a given function to create a new, "safe" version of the original function.

```{R, eval = require('purrr')}
safe_log <- purrr::safely(log)
```

The safe version returns a list of two items.
The first item is the result of calling the original function,
assuming no error occurred;
or `NULL` if an error did occur.
The second item is the error (if an error occurred) or `NULL` (if not).
Whether or not the original function would have thrown an error, the safe version will never throw an error.

```{r, eval = require('purrr')}
pair <- safe_log(10)
pair$result
pair$error
```

```{r, eval = require('purrr')}
pair <- safe_log('donald')
pair$result
pair$error
```

We can tighten and clarify calls to the safe function by using `%<-%.

```{r, eval = require('purrr')}
{ res : err } %<-% safe_log(10)
res
err
```

## Unpacking a data frame
A data frame is simply a list of columns,
so the *allotalot* assignment does what you expect.
It unpacks the data frame into individual columns.

```{r}
{ mpg : cyl : disp : hp } %<-% mtcars[,1:4]

head(mpg)

head(cyl)

head(disp)

head(hp)
```

### Example: List of data frames
Bear in mind that a list of data frames is still just a list.
The assignment will extract the list elements (which are data frames)
but not unpack the data frames themselves.

```{R}
{ mtc_hd : iris_hd: aq_hd } %<-% lapply(list(mtcars, iris, airquality), head, 3)

mtc_hd

iris_hd

aq_hd
```

Here we assigned three truncated data frames to three variables,
and the data frames are intact.

### Unpacking nested values
In addition to unpacking flat lists, we can unpack lists of lists.

```{r}
{a : { b : c } : d } %<-% list('begin', list('mid1', 'mid2'), 'end')
a
b
c
d
```

Not only does this simplify extracting individual elements,
it also adds a level of checking.
If the described list structure does not match the actual list structure,
an error is raised.

```{r, error=TRUE}
{a : { b : c : x} : d } %<-% list('begin', list('mid1', 'mid2'), 'end')
```

## Splitting a value to its parts
The previous examples dealt with unpacking a list or vector
into its elements.
We can also split certain kinds of individual values
into subvalues.

### Character vectors
We can assign individual characters of a string to variables.
Since character strings are vectors, do not forget to exclude braces from the assignment expression.

```{R}
ch1 : ch2 : ch3 %<-% 'abc'
ch1
ch2
ch3
```

### Dates
We can split a Date into its year, month, and day,
and assign the parts to variables.

```{r}
y : m : d %<-% Sys.Date()
y
m
d
```

### `lm` summary
(TBD)

### Class objects
*allotalot* includes implementations of `unpack` for atomic objects (numerics, characters, etc.), data frames, date objects, and linear model summaries. However, because `unpack` is a generic function we can define new implementations for custom classes. When defining a new implementation keep in mind the implementation needs to return a list so that values are properly unpacked.

## Trailing values: the "everything else" clause
In some cases, we want the first few elements of a list or vector
but don't care about the trailing elements.
The `summary` function of `lm`, for example,
returns a list of 11 values,
and we might want only the first few.
Fortunately, there is a way to capture those first few
and say "don't worry about everything else".

```{r}
f <- lm(mpg ~ cyl, data = mtcars)

{fcall : fterms : resids : ...rest} %<-% summary(f)

fcall

fterms

head(resids)
```

Here, `rest` will capture everything else.

```{r}
str(rest)
```

The assignment operator noticed that `...rest` is prefixed with `...`,
and it created a varable called `rest` for the trailing values of the list.
If we omitted the "everything else" prefix,
there would be an error because
the lengths of the left- and right-hand sides of the assignment would
be mismatched.

```{R, error = TRUE}
{fcall: fterms: resids: rest} %<-% summary(f)
```

Only one collector variable may be specified at each depth of names. If multiple collectors are specified `%<-%` will raise an error.

## Leading values and middle values
In addition to collecting trailing values, we can also collect initial values and assign remaining values.

```{R}
{ ...skip : e : f } %<-% list(1, 2, 3, 4, 5)
skip
e
f
```

Or we can assign the first value, skip values, and then assign the last value.

```{R}
{ init : ...middle : final } %<-% list(1, 2, 3, 4, 5)
init
middle
final
```

## Skipped values
We can skip one or more values without raising an error
by using a period (`.`) instead of a variable name.
For example, we might care only about the min, mean, and max
values of a vector's `summary`.

```{r}
min_wt : . : . : mean_wt : . : max_wt %<-% summary(mtcars$wt)
min_wt
mean_wt
max_wt
```

By combining an anonymous element (`.`) with the collector prefix, (`...`),
we can ignore whole sublists.

```{R}
{init: ....: final} %<-% list('hello', 'blah', list('blah'), 'blah', 'world!')
init
final
```

We can mix periods and collectors together
to selectively keep and discard elements.

```{R}
{ init : . : ...middle : final } %<-% as.list(1:5)
init
middle
final
```

### Swap values
One of the simple benefits of parallel assignment is swapping values
without the use of a temporary variable.

```{r}
first : last %<-% c('Ai', 'Genly')
first
last

first : last %<-% c(last, first)
first
last
```

or

```{r}
cat <- 'meow'
dog <- 'bark'

cat : dog : fish %<-% c(dog, cat, dog)
cat
dog
fish
```
