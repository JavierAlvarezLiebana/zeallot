---
title: "Parallel, Multiple, and Unpacking Assignment"
author: "Nathan Teetor"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Parallel, Multiple, and Unpacking Assignment}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{R, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = '#>')
knitr::knit_theme$set('leo')

library(allotalot)
```

## Parallel Assignment

Parallel assignment is the assignment of multiple variables at once. Languages, such as Python or Go, which allow parallel assignment do so with syntax similar to the following.

```{python}
a, b = 1, 2
a
#>>> 1
b
#>>> 2
```

In the above example we see `a` and `b` are both assigned in the first line, but with two distinct values. R allows a watered-down version of parallel assignment, but the variables cannot be assigned distinct values.

```{R}
a <- b <- 1
a
b
```

Note that, although assigning two distinct values in one line is the emphasis of the above example, the same value may be assigned, but must be specified the correct number of times, see below.

```{python}
a, b = 1, 1
a
#>>> 1
b
#>>> 1
```

Now that we have seen a straightforward example, let's take a look at a slightly more complex and more practical example.

### Python Examples

The following Python code illustrates unpacking assignment.

```{python}
def coords():
  '''A function which returns a list of 2 numbers (coordinates)'''
  return [38.061944, -122.643889]
  
lat, lng = coords()
lat
#>>> 38.061944
lng
#>>> -122.643889
```

The list of values returned by `coords()` is unpacked into the two variables `lat` and `lng`, hence this case of parallel assignment is more aptly referred to as *unpacking assignment*. We could also refer to this as *destructuring assignment*. Additionally, we can unpack a list without using a function call and we can unpack more than only two values.

```{python}
point = [3, 5, 8]
x, y, z = point
x
#>>> 3
y
#>>> 5
z
#>>> 8
point
#>>> [3, 5, 8]
```

In addition to unpacking flat lists, we can unpack values in nested lists. The following example illustrates what we might expect based on the previous examples.

```{python}
nested = [4, [0, 1]]
a, b = nested
a
#>>> 4
b
#>>> [0, 1]
```

But, if we add a variable `c` and nest `b` and `c` on the left-hand side we get a different result.

```{python}
nested = [4, [0, 1]]
a, (b, c) = nested
a
#>>> 4
b
#>>> 0
c
#>>> 1
```

Now that we have seen a few examples, let's move on to parallel assignment in R using allotalot.

## The %<-% Operator

allotalot provides the `%<-%` operator for parallel assignment, remember this includes unpacking assignment. Here is the first example from above rewritten in R using `%<-%`.

```{R}
.(a, b) %<-% list(1, 2)
a
b
```

Using some very simple syntax we can swap the values of `a` and `b` without using a temporary variable, see below.

```{R}
.(a, b) %<-% list(b, a)
a
b
```

### The . Helper

allotalot provides the `.()` function, used on the left-hand side of an assignment expression. Because R does not support nesting variables (e.g. `a, (b, c)` or even `a, b`) allotalot provides `.()` in order to work around these restrictions. `.()` is very similar to `list()`, but helps keep the left-hand side of our expressions cleaner and more concise by allowing bare names and imposing a limited syntax. Only bare or quoted names and further calls to `.()` are allowed within a call to `.()`.

### R Examples

Now let's work through further examples of parallel assingment in R. In the first example, we use nested calls to `.()` on the left-hand side to unpack a nested list on the right-hand side.

```{R}
.(a, .(c, d), b) %<-% list('once', list('upon', 'a'), 'time')
a
b
c
d
```

Here we unpack a function's return value.

```{R}
odds <- function(x) {
  the_odds <- x %% 2 == 1
  list(
    sum(the_odds),
    x[the_odds]
  )
}
.(num_odds, values) %<-% odds(sample(100, 25))
num_odds
values
```

This next example requires the purrr package. From purrr we will use the `safely()` function. By passing a function to `safely()`, we can create a new "safe" version of that function. This safe version always produces an output of two values. The first value is the result of calling the function, if no error occurred, and the second value is an error, if an error occurred. This safe function never throws an error, instead we can expect the first value to be `NULL` and the second value to be the error.

```{R, eval = require('purrr')}
# make sure purrr is installed
# install.packages('purrr')

safe_log <- purrr::safely(log)

tuple <- safe_log(10)
tuple$result
tuple$error
```

The above example code is no deal breaker. But, allotalot aims to improve quality of life and code by allowing more explicit variable naming and cutting down on repititions like the repeated extractions from `tuple`. See below for how we can rework the example using allotalot.


```{R, eval = require('purrr')}
# if `res` and `err` are still not explicit enough we could use
# `result` and `error`. In either case we are clearly name and 
# unpack the return values of our safe function. 
.(res, err) %<-% safe_log(10)
res
err

.(res, err) %<-% safe_log("a number")

if (!is.null(err)) {
  # and here we could do more than print a message
  message('could not compute log, ', err$message)
}

# continuing with the purrr example
x <- list(20, 'gulp', 17)

log_x <- purrr::map(x, safe_log)
log_x

for (i in seq_along(log_x)) {
  .(res, err) %<-% log_x[[i]]
  
  if (!is.null(err)) {
    message('problem with result ', i)
    next
  }
  
  message('result ', i, ' is ', res)
}
```

